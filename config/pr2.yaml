general_options:
  sample_period: 0.05 # time[s] between points of generated joint trajectory
  map_frame: map
  debug: False # enables debug prints and prints the behavior tree state in the terminal
  fill_velocity_values: True # due to a bug, the pr2 does not want the velocity values to be filled
  joint_limits: # giskard will use the min of this number and limits from the urdf
    velocity:
      linear: # m/s
        default: 1
        override:
          odom_x_joint: 0.5
          odom_y_joint: 0.5
      angular: # rad/s
        default: 1
        override:
          odom_z_joint: 0.6
          head_pan_joint: 0.5
          head_tilt_joint: 0.5
    acceleration: # multiply your desired acc limit with sample period; experimental, don't touch
      linear: # m/s**2
        default: 1e3
        override: {}
      angular: # rad/s**2
        default: 1e3
        override: {}
    jerk: # multiply your desired acc limit with sample period; experimental, don't touch
      linear: # m/s**2
        default: 30
        override: {}
      angular: # rad/s**2
        default: 30
        override: {}
  joint_weights:
    # the planner prefers low weight joints to achieve solutions
    # higher weights reduce wiggling, but lower the maximum joint velocity, which might make the planner stop too early
    velocity:
      default: 0.01
      override:
        odom_x_joint: 0.1
        odom_y_joint: 0.1
        odom_z_joint: 0.1
        torso_lift_joint: 0.05
    acceleration:
      default: 0
      override: {}
    jerk:
      default: 0
      override: {}
qp_solver:
  name: gurobi # one of [qpoases, gurobi]
  prediction_horizon: 8
  control_horizon: 8
plugins:
  GoalReached:
    joint_convergence_threshold: 0.01 # when the velocities fall below this value, the planning succeeds
    window_size: 21 # in sample points, should be identical to WiggleCancel window_size
  VisualizationBehavior: # planning visualization through markers, slows planning down a little bit
    enabled: True
  WorldVisualizationBehavior: # planning world visualization through markers, slows planning down a little bit
    enabled: True
  CPIMarker: # contact visualization, slows planning down a little bit
    enabled: True
  PlotTrajectory: # plots the joint trajectory at the end of planning, useful for debugging
    enabled: True
    velocity_threshold: 0.0 # only joints that exceed this velocity threshold will be added to the plot. Use a negative number if you want to include every joint
    scaling: 2.5 # determines how much the x axis is scaled with the length(time) of the trajectory
    normalize_position: False # centers the joint positions around 0 on the y axis
    tick_stride: 0.5 # the distance between ticks in the plot. if tick_stride <= 0 pyplot determines the ticks automatically
  WiggleCancel: # cancels planning if high frequencies are detected in the trajectory
    amplitude_threshold: 0.28 # the amplitude of a frequency must exceed this threshold to be detected as wiggling
    window_size: 21 # size of the moving window of sample points
    frequency_range: 0.4 # must be in the range [0,1]. Only frequencies in the range [max_detectable_frequency * wiggle_frequency_range, max_detectable_frequency] are considered as wiggling. So a value of 0 means that every frequency with an amplitude above wiggle_detection_threshold is detected as wiggling and a value of 1 means that only the max_detectable_frequency can trigger a wiggle detection.      max_detectable_frequency = 1 / (2 * sample_period)
  tf_publisher:
    publish_attached_objects: True
    publish_world_objects: False
    tf_topic: /tf
reachability_check:
  sample_period: 0.5
  prismatic_velocity: 2.0
  continuous_velocity: 1
  revolute_velocity: 1
  other_velocity: 1
behavior_tree:
  tree_tick_rate: 0.1 # how often the tree updates. lower numbers increase responsiveness, but waste cpu time while idle
collision_avoidance:
  external_collision_avoidance:
    distance_thresholds: # external thresholds are per joint, they therefore count for all directly controlled links
      default:
        hard_threshold: 0.0 # at this distance in [cm] that can not be surpassed
        soft_threshold: 0.1 # robot links are pushed to that distance, but it can be overpowered with high weight constraints
      override:
        zero: &zero
          hard_threshold: 0.0
          soft_threshold: 0.0
        5cm: &5cm
          hard_threshold: 0.0
          soft_threshold: 0.05
        25mm: &25mm
          hard_threshold: 0.0
          soft_threshold: 0.025
        odom_z_joint: # this affects all links between this and the next controlled joint
          hard_threshold: 0.05 # at this distance in [cm] that can not be surpassed
          soft_threshold: 0.1 # robot links are pushed to that distance, but it can be overpowered with high weight constraints
        r_forearm_roll_joint: *25mm
        l_forearm_roll_joint: *25mm
        r_elbow_flex_joint: *5cm
        l_elbow_flex_joint: *5cm
        r_wrist_roll_joint: *5cm
        l_wrist_roll_joint: *5cm
        r_wrist_flex_joint: *5cm
        l_wrist_flex_joint: *5cm
    # each controlled joint gets pushed away from its X nearest objects
    # to reduce the runtime, you can set different values for joints that control end effectors
    number_of_repeller:
      default: 1
      end_effector_joints: 4
  self_collision_avoidance:
    distance_thresholds: # thresholds for self collision avoidance are set for each link pair
      default: &default # you can set variables and reuse them
        hard_threshold: 0.0 # at this distance in [cm] that can not be surpassed
        soft_threshold: 0.05 # robot links are pushed to that distance, but it can be overpowered with high weight constraints
      override:
        # examples, that don't have an affect:
        base_link: *default  # this would count for all pairs containing 'base_link', if not specified otherwise
        base_link, r_upper_arm_link: *default # you can set thresholds for specific pairs
        bl_caster_l_wheel_link: *zero
        bl_caster_r_wheel_link: *zero
        bl_caster_rotation_link: *zero
        br_caster_l_wheel_link: *zero
        br_caster_r_wheel_link: *zero
        br_caster_rotation_link: *zero
        fl_caster_l_wheel_link: *zero
        fl_caster_r_wheel_link: *zero
        fl_caster_rotation_link: *zero
        fr_caster_l_wheel_link: *zero
        fr_caster_r_wheel_link: *zero
        fr_caster_rotation_link: *zero
    ignore: [] # list pairs of links that should be removed from the self collision avoidance
#    ignore: #example
#      - [base_link, l_upper_arm_link]
    add: [] # list pairs of links that should be added to the self collision matrix
    number_of_repeller: 1 # each movable joint gets pushed away from the X objects closest to it
